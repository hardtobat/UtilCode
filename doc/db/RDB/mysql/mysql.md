# mysql问题
1. B+树与B树的不同在于：
   （1）所有关键字存储在叶子节点，非叶子节点不存储真正的data
   （2）为所有叶子节点增加了一个链指针
2. innodb和myisam区别：
    1> myisam只支持表级锁,不支持事务
       Innodb支持事务和行级锁，是innodb的最大特色
    2>

3. 事务的隔离级别   
   1> 读未提交  
   2> 读已提交[大多数数据库的默认事务隔离级别] 解决了脏读的问题 无GAP锁  
   3> 可重复读[mysql的默认事务隔离级别]
        解决了不可重复度和脏读的问题[通过MVCC解决了不可重复度]  
   4> 串行化 解决了脏读，幻读，不可重复度 的问题 [幻读主要是通过间隙锁来解决的]   
   针对问题： 1> 脏读: 读到了未提交的数据  
   2> 幻读: 同一事务中读到了另外一个事务新插入的数据  
   3> 不可重复度:同一事务中读到了另外一个事务update或delete的数据
4. mysql锁
    * 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
    * 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
    * 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般  
    1> myisam 是表级锁  
    2> innodb是行级锁:  
     innoDB实现了以下两种类型的行锁。
     共享锁（s）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
     排他锁（Ｘ）：允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。
     另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。
     意向共享锁（IS）：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
     意向排他锁（IX）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。  

 | 前锁模式/是否兼容/请求锁模式 | X | IX | S | IS |
 | :--: | :--: | :--: | :--: | :--: |
 | X | 冲突 | 冲突 | 冲突 | 冲突 |
 | IX | 冲突 | 兼容 | 冲突 | 兼容 |
 | S | 冲突 | 冲突 | 兼容 | 兼容 |
 | IS | 冲突 | 兼容 | 兼容 | 兼容 |  
    3> Innodb 锁的算法： 1>> 锁记录 2>> 间隙锁 3>> next-key 锁  
    详见 [mysql 锁](http://hedengcheng.com/?p=771#_Toc374698322)

 
