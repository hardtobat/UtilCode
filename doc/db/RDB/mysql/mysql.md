# mysql问题
1. B+树与B树的不同在于：
   （1）所有关键字存储在叶子节点，非叶子节点不存储真正的data
   （2）为所有叶子节点增加了一个链指针
2. innodb和myisam区别：
    1> myisam只支持表级锁,不支持事务
       Innodb支持事务和行级锁，是innodb的最大特色
    2>

3. 事务的隔离级别   
   1> 读未提交  
   2> 读已提交[大多数数据库的默认事务隔离级别] 解决了脏读的问题 无GAP锁  
   3> 可重复读[mysql的默认事务隔离级别]
   解决了不可重复度和脏读的问题[通过MVCC解决了不可重复度]
   此阶段可以通过next_key锁解决幻读问题  
   4> 串行化 解决了脏读，幻读，不可重复度 的问题
   
   针对问题： 1> 脏读: 读到了未提交的数据  
   2> 幻读: 同一事务中读到了另外一个事务新插入的数据  
   3> 不可重复度:同一事务中读到了另外一个事务update或delete的数据
4. mysql锁
    * 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
    * 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
    * 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般  
    1> myisam 是表级锁  
    2> innodb是行级锁:  
     innoDB实现了以下两种类型的行锁。
     共享锁（s）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
     排他锁（Ｘ）：允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。
     另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。
     意向共享锁（IS）：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
     意向排他锁（IX）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。  

 | 前锁模式/是否兼容/请求锁模式 | X | IX | S | IS |
 | :--: | :--: | :--: | :--: | :--: |
 | X | 冲突 | 冲突 | 冲突 | 冲突 |
 | IX | 冲突 | 兼容 | 冲突 | 兼容 |
 | S | 冲突 | 冲突 | 兼容 | 兼容 |
 | IS | 冲突 | 兼容 | 兼容 | 兼容 |  
    3> Innodb 锁的算法： 1>> 锁记录 2>> 间隙锁 3>> next-key 锁  
    详见 [mysql 锁](http://hedengcheng.com/?p=771#_Toc374698322)  
5. MVCC   
   多版本并发控制：   
   在查询时要符合以下两个条件的记录才能被事务查询出来：  
   1>
   删除版本号未指定或者大于当前事务版本号，即查询事务开启后确保读取的行未被删除。(即上述事务id为2的事务查询时，依然能读取到事务id为3所删除的数据行)
   创建版本号 小于或者等于  
   2>当前事务版本号，就是说记录创建是在当前事务中（等于的情况）或者在当前事务启动之前的其他事物进行的insert
   
补充：   
1.MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）.  
2.Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC.原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。
3.串行化由于是会对所涉及到的表加锁，并非行锁，自然也就不存在行的版本控制问题。
4.通过以上总结，可知，MVCC主要作用于事务性的，有行锁控制的数据库模型。