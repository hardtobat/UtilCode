1. 如何减少上下文切换:
    1. 无锁并发编程:
    2. CAS算法:
    3. 使用最少线程:避免创建不必要的线程,比如任务很少,但是创建了很多线程来处理.这样会造成大量线程都处在等待状态
    4. 使用协成:在单线程里实现多任务的调度,并在单线程里维持多个任务间的切换
2. 死锁,详见DEAD-LOCK
   锁: 无锁状态->偏向锁->轻量级锁->重量级锁
3. volatile
   保证此变量对所有的线程的可见性;禁止指令重排序优化
   从汇编角度上看:
   volatile Singleton instance = new Singleton()转成汇编语言后,会加上一条lock 开头的指令.该指令实现了2个功能:<1> 将当前处理器缓存行的数据协会到系统内存.<2> 这个歇会内存的操作会使在其他CPU里缓存了该内存地址的数据无效.
   1> 实现原则:
        1.Lock前缀指令会引起处理器缓存写回到内存.
        2.一个处理器的缓存回写到内存会导致其他处理器的缓存无效.
4. 原子操作:
   处理器通过两种手段实现原子操作:
   1> 使用总线锁:当一个处理器在总线上输出LOCK信号时,其他处理器的请求将被阻塞住,那么该处理器可以独占共享内存.
   2> 使用缓存锁:只需要保证某个内存地址的操作是原子性的即可.这种办法比总线索的开销要小.
5. CAS:
   1> 缺点:ABA问题,使用AtomicStampedReference
          循环时间长,开销大
          只能保证一个共享变量的原子操作
6. 重排序
   重排序分为3种:  
   >> 1> 编译器优化的重排序.编译器在不改变单线程程序语义的前提下.可以重新安排语句的执行顺序.  
   >> 2> 指令级并行的重排序.现代处理器采用了指令级并行技术来将多条指令重叠执行.如果不存在数据依赖性.处理器可以改变语句对应机器指令的执行顺序.  
   >> 3> 内存系统的重排序,由于处理器使用缓存和读/写缓冲区.这是得加载和存储操作看上去可能是在乱序执行.  
   
   从java源码到最终实际执行的指令序列,分别会经历如下3种重排序:  
   >> 源代码 -> 编译器优化重排序 [编译器重排序] -> 指令级并行重排序 [处理器重排序] -> 内存系统重排序 [处理器重排序] -> 最终执行的指令序列  
   
   这些重排序可能会导致多线程程序出现内存可见性问题.  
   1> 对于编译器,JMM[java内存模型]的编译器重排序规则会进制特定类型的编译器重排序(不是所有的编译器重排序都要禁止).  
   2> 对于处理器重排序,JMM的处理器重排序规则会要求JAVA编译器在生成指令序列时,插入特定类型的内存屏障指令,通过内存屏障指令来禁止特定类型的处理器重排序.  
   JMM通过禁止特定类型的编译器重排序和处理器重排序,为程序员提供一致的内存可见性保证  
   
   java内存屏障类型如下表:  
   ![内存屏障](./memoryBarria.png)
 

