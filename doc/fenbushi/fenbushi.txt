https://www.cnblogs.com/stateis0/category/1206895.html
1. CAP  理论： 系统设计一般3选2
   1> C : 一致性：指数据在多个副本之间能够保持一致的特性（严格的一致性）
   2> A : 可用性，指系统提供的服务必须一直处于可用的状态，每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据。
   3> P ：分区容错性：分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障
   其中分区是指：在分布式系统中，不同的节点分布在不同的子网络中，每个子网络就叫做一个区,由于一些特殊的原因，这些区之间出现了网络不通的状态，但他们的内部子网络是正常的。从而导致了整个系统的环境被切分成了若干个孤立的区域。这就是分区。
仔细想想，分区是百分之百出现的吗？如果不出现分区，那么就能够同时满足 CAP。如果出现了分区，可以根据策略进行调整。比如 C 不必使用那么强的一致性，可以先将数据存起来，稍后再更新，实现所谓的 “最终一致性”。就是BASE理论。
2. BASE 理论：
    Basically Available(基本可用)
        什么是基本可用呢？假设系统，出现了不可预知的故障，但还是能用，相比较正常的系统而言：
        响应时间上的损失：正常情况下的搜索引擎 0.5 秒即返回给用户结果，而基本可用的搜索引擎可以在 1 秒作用返回结果。
        功能上的损失：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单，但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。
    Soft state（软状态）
        什么是软状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种 “硬状态”。
        软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。
    Eventually consistent（最终一致性）
        系统能够保证在没有其他新的更新操作的情况下，数据最终一定能够达到一致的状态，因此所有客户端对系统的数据访问最终都能够获取到最新的值。
        而在实际工程实践中，最终一致性分为 5 种：
        1. 因果一致性（Causal consistency）
        指的是：如果节点 A 在更新完某个数据后通知了节点 B，那么节点 B 之后对该数据的访问和修改都是基于 A 更新后的值。于此同时，和节点 A 无因果关系的节点 C 的数据访问则没有这样的限制。
        2. 读己之所写（Read your writes）
        这种就很简单了，节点 A 更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性。
        3. 会话一致性（Session consistency）
        会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现 “读己之所写” 的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。
        4. 单调读一致性（Monotonic read consistency）
        单调读一致性是指如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。
        5. 单调写一致性（Monotonic write consistency）
        指一个系统要能够保证来自同一个节点的写操作被顺序的执行。
        然而，在实际的实践中，这 5 种系统往往会结合使用，以构建一个具有最终一致性的分布式系统。实际上，不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的，比如备份，数据库的复制过程是需要时间的，这个复制过程中，业务读取到的值就是旧的。当然，最终还是达成了数据一致性。这也算是一个最终一致性的经典案例。
    Base 理论是对 CAP 中一致性和可用性权衡的结果，其来源于对大型互联网分布式实践的总结，是基于 CAP 定理逐步演化而来的。
    其核心思想是：既是无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。
 3. 2PC(2段式提交)
    JPA规范： atomik框架
    主要分为: 协调者和参与者
    阶段一， 提交事务请求
        1. 事务询问：协调者向所有参与者发送事务内容。询问是否可以之行事务提交操作，并开始等待各参与者的响应。
        2. 执行事务：各参与者节点之行事务操作。并将undo和redo信息记录到事务日志中。
        3. 各参与者向协调者反馈事务询问的响应。如果参与者之行成功了事务，则返回yes，表示事务可以执行。如果参与者没有成功执行事务，纳闷反馈给协调者no,表示事务不可执行。该操作类似与投票的操作。
    阶段二，执行事务提交
        1。参与者返回都是yes.  则执行：1. 协调者发送提交请求。2。参与者事务提交。3。参与者反馈事务提交结果。4。协调者完成事务。
    缺点：
        单点问题：事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在***阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。
        同步阻塞：在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。
        数据不一致：两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能。
    优点：
        尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现，对于 MySQL 是从 5.5 开始支持。